// Code generated by goa v3.0.10, DO NOT EDIT.
//
// tmess gRPC client encoders and decoders
//
// Command:
// $ goa gen terminal-chat/design

package client

import (
	"context"
	tmesspb "terminal-chat/gen/grpc/tmess/pb"
	tmess "terminal-chat/gen/tmess"

	goagrpc "goa.design/goa/v3/grpc"
	"google.golang.org/grpc"
	"google.golang.org/grpc/metadata"
)

// BuildLoginFunc builds the remote method to invoke for "tmess" service
// "login" endpoint.
func BuildLoginFunc(grpccli tmesspb.TmessClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb interface{}, opts ...grpc.CallOption) (interface{}, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.Login(ctx, reqpb.(*tmesspb.LoginRequest), opts...)
		}
		return grpccli.Login(ctx, &tmesspb.LoginRequest{}, opts...)
	}
}

// EncodeLoginRequest encodes requests sent to tmess login endpoint.
func EncodeLoginRequest(ctx context.Context, v interface{}, md *metadata.MD) (interface{}, error) {
	payload, ok := v.(*tmess.LoginPayload)
	if !ok {
		return nil, goagrpc.ErrInvalidType("tmess", "login", "*tmess.LoginPayload", v)
	}
	(*md).Append("user", payload.User)
	(*md).Append("password", payload.Password)
	return NewLoginRequest(), nil
}

// DecodeLoginResponse decodes responses from the tmess login endpoint.
func DecodeLoginResponse(ctx context.Context, v interface{}, hdr, trlr metadata.MD) (interface{}, error) {
	message, ok := v.(*tmesspb.LoginResponse)
	if !ok {
		return nil, goagrpc.ErrInvalidType("tmess", "login", "*tmesspb.LoginResponse", v)
	}
	res := NewLoginResult(message)
	return res, nil
}

// BuildEchoerFunc builds the remote method to invoke for "tmess" service
// "echoer" endpoint.
func BuildEchoerFunc(grpccli tmesspb.TmessClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb interface{}, opts ...grpc.CallOption) (interface{}, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.Echoer(ctx, opts...)
		}
		return grpccli.Echoer(ctx, opts...)
	}
}

// EncodeEchoerRequest encodes requests sent to tmess echoer endpoint.
func EncodeEchoerRequest(ctx context.Context, v interface{}, md *metadata.MD) (interface{}, error) {
	payload, ok := v.(*tmess.EchoerPayload)
	if !ok {
		return nil, goagrpc.ErrInvalidType("tmess", "echoer", "*tmess.EchoerPayload", v)
	}
	(*md).Append("authorization", payload.Token)
	return nil, nil
}

// DecodeEchoerResponse decodes responses from the tmess echoer endpoint.
func DecodeEchoerResponse(ctx context.Context, v interface{}, hdr, trlr metadata.MD) (interface{}, error) {
	return &EchoerClientStream{
		stream: v.(tmesspb.Tmess_EchoerClient),
	}, nil
}

// BuildListenerFunc builds the remote method to invoke for "tmess" service
// "listener" endpoint.
func BuildListenerFunc(grpccli tmesspb.TmessClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb interface{}, opts ...grpc.CallOption) (interface{}, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.Listener(ctx, opts...)
		}
		return grpccli.Listener(ctx, opts...)
	}
}

// EncodeListenerRequest encodes requests sent to tmess listener endpoint.
func EncodeListenerRequest(ctx context.Context, v interface{}, md *metadata.MD) (interface{}, error) {
	payload, ok := v.(*tmess.ListenerPayload)
	if !ok {
		return nil, goagrpc.ErrInvalidType("tmess", "listener", "*tmess.ListenerPayload", v)
	}
	(*md).Append("authorization", payload.Token)
	return nil, nil
}

// DecodeListenerResponse decodes responses from the tmess listener endpoint.
func DecodeListenerResponse(ctx context.Context, v interface{}, hdr, trlr metadata.MD) (interface{}, error) {
	return &ListenerClientStream{
		stream: v.(tmesspb.Tmess_ListenerClient),
	}, nil
}

// BuildSummaryFunc builds the remote method to invoke for "tmess" service
// "summary" endpoint.
func BuildSummaryFunc(grpccli tmesspb.TmessClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb interface{}, opts ...grpc.CallOption) (interface{}, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.Summary(ctx, opts...)
		}
		return grpccli.Summary(ctx, opts...)
	}
}

// EncodeSummaryRequest encodes requests sent to tmess summary endpoint.
func EncodeSummaryRequest(ctx context.Context, v interface{}, md *metadata.MD) (interface{}, error) {
	payload, ok := v.(*tmess.SummaryPayload)
	if !ok {
		return nil, goagrpc.ErrInvalidType("tmess", "summary", "*tmess.SummaryPayload", v)
	}
	(*md).Append("authorization", payload.Token)
	return nil, nil
}

// DecodeSummaryResponse decodes responses from the tmess summary endpoint.
func DecodeSummaryResponse(ctx context.Context, v interface{}, hdr, trlr metadata.MD) (interface{}, error) {
	var view string
	{
		if vals := hdr.Get("goa-view"); len(vals) > 0 {
			view = vals[0]
		}
	}
	return &SummaryClientStream{
		stream: v.(tmesspb.Tmess_SummaryClient),
		view:   view,
	}, nil
}

// BuildSubscribeFunc builds the remote method to invoke for "tmess" service
// "subscribe" endpoint.
func BuildSubscribeFunc(grpccli tmesspb.TmessClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb interface{}, opts ...grpc.CallOption) (interface{}, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.Subscribe(ctx, reqpb.(*tmesspb.SubscribeRequest), opts...)
		}
		return grpccli.Subscribe(ctx, &tmesspb.SubscribeRequest{}, opts...)
	}
}

// EncodeSubscribeRequest encodes requests sent to tmess subscribe endpoint.
func EncodeSubscribeRequest(ctx context.Context, v interface{}, md *metadata.MD) (interface{}, error) {
	payload, ok := v.(*tmess.SubscribePayload)
	if !ok {
		return nil, goagrpc.ErrInvalidType("tmess", "subscribe", "*tmess.SubscribePayload", v)
	}
	(*md).Append("authorization", payload.Token)
	return NewSubscribeRequest(), nil
}

// DecodeSubscribeResponse decodes responses from the tmess subscribe endpoint.
func DecodeSubscribeResponse(ctx context.Context, v interface{}, hdr, trlr metadata.MD) (interface{}, error) {
	return &SubscribeClientStream{
		stream: v.(tmesspb.Tmess_SubscribeClient),
	}, nil
}

// BuildHistoryFunc builds the remote method to invoke for "tmess" service
// "history" endpoint.
func BuildHistoryFunc(grpccli tmesspb.TmessClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb interface{}, opts ...grpc.CallOption) (interface{}, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.History(ctx, reqpb.(*tmesspb.HistoryRequest), opts...)
		}
		return grpccli.History(ctx, &tmesspb.HistoryRequest{}, opts...)
	}
}

// EncodeHistoryRequest encodes requests sent to tmess history endpoint.
func EncodeHistoryRequest(ctx context.Context, v interface{}, md *metadata.MD) (interface{}, error) {
	payload, ok := v.(*tmess.HistoryPayload)
	if !ok {
		return nil, goagrpc.ErrInvalidType("tmess", "history", "*tmess.HistoryPayload", v)
	}
	if payload.View != nil {
		(*md).Append("view", *payload.View)
	}
	(*md).Append("authorization", payload.Token)
	return NewHistoryRequest(), nil
}

// DecodeHistoryResponse decodes responses from the tmess history endpoint.
func DecodeHistoryResponse(ctx context.Context, v interface{}, hdr, trlr metadata.MD) (interface{}, error) {
	var view string
	{
		if vals := hdr.Get("goa-view"); len(vals) > 0 {
			view = vals[0]
		}
	}
	return &HistoryClientStream{
		stream: v.(tmesspb.Tmess_HistoryClient),
		view:   view,
	}, nil
}
